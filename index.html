<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tetris</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        #container {
            width: 800px;
            height: 800px;
            border: 2px solid #00D9FF;
        }
        #info-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .info-box {
            background-color: #1a1a3e;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #00D9FF;
        }
        .info-box h3 {
            margin: 0 0 10px 0;
            color: #00D9FF;
        }
        #next-piece {
            width: 100px;
            height: 100px;
        }
        #score, #lines, #level {
            font-size: 24px;
            font-weight: bold;
        }
        .controls {
            font-size: 12px;
            line-height: 1.5;
        }
    </style>
</head>

<body>
    <div id="game-wrapper">
        <div id="container"></div>
        <div id="info-panel">
            <div class="info-box">
                <h3>NEXT</h3>
                <div id="next-piece"></div>
            </div>
            <div class="info-box">
                <h3>SCORE</h3>
                <div id="score">0</div>
            </div>
            <div class="info-box">
                <h3>LINES</h3>
                <div id="lines">0</div>
            </div>
            <div class="info-box">
                <h3>LEVEL</h3>
                <div id="level">1</div>
            </div>
            <div class="info-box controls">
                <h3>CONTROLS</h3>
                <div>← → : Move</div>
                <div>↑ / Z : Rotate</div>
                <div>↓ : Soft Drop</div>
                <div>Space : Hard Drop</div>
            </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById("container");
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(
            55,
            container.clientWidth / container.clientHeight,
            0.1,
            1000
        );

        camera.position.set(4.5, 9.5, 25);
        camera.lookAt(4.5, 9.5, 0);

        const scene = new THREE.Scene();

        const numRows = 20;
        const numCols = 10;
        const blockSize = 1;

        // フレームをEdgesGeometryで作成（対角線なし）
        const frameGeometry = new THREE.BoxGeometry(
            numCols * blockSize,
            numRows * blockSize,
            blockSize
        );
        
        // EdgesGeometryを使用（これは辺のみを作成し、対角線は含まない）
        const edges = new THREE.EdgesGeometry(frameGeometry);
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00D9FF,  // スカイブルーに変更（テトリミノのI型と同じ色）
            linewidth: 2 
        });
        const frame = new THREE.LineSegments(edges, lineMaterial);
        
        frame.position.set(
            (numCols * blockSize / 2) - blockSize / 2,
            (numRows * blockSize / 2) - blockSize / 2,
            0
        );
        
        scene.add(frame);
        
        // 濃い紺色の背景を追加
        const bgGeometry = new THREE.PlaneGeometry(
            numCols * blockSize,
            numRows * blockSize
        );
        const bgMaterial = new THREE.MeshBasicMaterial({
            color: 0x0a0a2e,  // 濃い紺色
            side: THREE.DoubleSide
        });
        const background = new THREE.Mesh(bgGeometry, bgMaterial);
        background.position.set(
            (numCols * blockSize / 2) - blockSize / 2,
            (numRows * blockSize / 2) - blockSize / 2,
            -blockSize / 2
        );
        scene.add(background);
        
        // 背景の外枠（青色）を追加
        const bgEdges = new THREE.EdgesGeometry(bgGeometry);
        const bgEdgeMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00D9FF,
            linewidth: 2
        });
        const bgFrame = new THREE.LineSegments(bgEdges, bgEdgeMaterial);
        bgFrame.position.copy(background.position);
        scene.add(bgFrame);
        
        // 白いグリッド線を追加（背景と同じ深さに配置）
        const gridGroup = new THREE.Group();
        const gridMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            opacity: 0.2,
            transparent: true
        });
        
        const gridZ = -blockSize / 2 + 0.01; // 背景の少し前
        
        // 縦線（ブロックの境界に配置）
        for (let i = 0; i <= numCols; i++) {
            const points = [];
            const x = i * blockSize - blockSize / 2;
            points.push(new THREE.Vector3(x, -blockSize / 2, gridZ));
            points.push(new THREE.Vector3(x, numRows * blockSize - blockSize / 2, gridZ));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            gridGroup.add(line);
        }
        
        // 横線（ブロックの境界に配置）
        for (let i = 0; i <= numRows; i++) {
            const points = [];
            const y = i * blockSize - blockSize / 2;
            points.push(new THREE.Vector3(-blockSize / 2, y, gridZ));
            points.push(new THREE.Vector3(numCols * blockSize - blockSize / 2, y, gridZ));
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, gridMaterial);
            gridGroup.add(line);
        }
        
        scene.add(gridGroup);

        function createBoard(rows, cols) {
            const matrix = [];
            for (let i = 0; i < rows; i++) {
                matrix.push(new Array(cols).fill(0));
            }
            return matrix;
        }

        let board = createBoard(numRows, numCols);
        
        // ゲーム状態の変数
        let score = 0;
        let lines = 0;
        let level = 1;
        let nextTetromino = null;
        
        // Next piece用のシーンとレンダラー
        const nextContainer = document.getElementById("next-piece");
        const nextRenderer = new THREE.WebGLRenderer();
        nextRenderer.setSize(100, 100);
        nextContainer.appendChild(nextRenderer.domElement);
        
        const nextCamera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
        nextCamera.position.set(1.5, 1, 5);
        nextCamera.lookAt(1.5, 1, 0);
        
        const nextScene = new THREE.Scene();
        let nextPieceGroup = null;
        let nextRotationGroup = null;
        
        // ライン消去エフェクト用の変数
        let clearingLines = [];
        let clearAnimationStart = null;
        const clearAnimationDuration = 500; // 0.5秒

        function drawBoard() {
            const group = new THREE.Group();
            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {
                    if (board[row][col]) {
                        const cubeGeometry = new THREE.BoxGeometry(
                            blockSize,
                            blockSize,
                            blockSize
                        );
                        const cubeMaterial = new THREE.MeshBasicMaterial({
                            color: tetrominoColors[board[row][col] - 1],
                        });
                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        
                        // 黒い線（エッジ）を追加
                        const edgeGeometry = new THREE.EdgesGeometry(cubeGeometry);
                        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                        const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                        cube.add(edges);
                        
                        cube.position.set(
                            col * blockSize,
                            (numRows - 1 - row) * blockSize,
                            0
                        );
                        group.add(cube);
                    }
                }
            }
            return group;
        }

        let boardGroup = drawBoard();
        scene.add(boardGroup);

        // Tetromino shape definitions
        const tetrominoShapes = [
            [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 2, y: 0 },
                { x: 3, y: 0 },
            ],
            [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
            ],
            [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 1, y: 1 },
                { x: 2, y: 1 },
            ],
            [
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 1, y: 0 },
                { x: 2, y: 0 },
            ],
            [
                { x: 0, y: 0 },
                { x: 1, y: 0 },
                { x: 2, y: 0 },
                { x: 2, y: 1 },
            ],
            [
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 2, y: 1 },
                { x: 2, y: 0 },
            ],
            [
                { x: 1, y: 0 },
                { x: 0, y: 1 },
                { x: 1, y: 1 },
                { x: 2, y: 1 },
            ],
        ];

        const tetrominoColors = [
            0x00D9FF,  // I - スカイブルー
            0xFFD700,  // O - ゴールド
            0x50E3C2,  // S - ミントグリーン
            0xFF6B6B,  // Z - コーラルレッド
            0x4169E1,  // J - ロイヤルブルー
            0xFF8C42,  // L - サンセットオレンジ
            0xB19CD9,  // T - ソフトパープル
        ];

        function createTetromino() {
            const shapeIndex = Math.floor(Math.random() * tetrominoShapes.length);
            const shape = JSON.parse(JSON.stringify(tetrominoShapes[shapeIndex])); // Deep copy the shape
            const color = tetrominoColors[shapeIndex];

            const group = new THREE.Group();

            for (let i = 0; i < shape.length; i++) {
                const cubeGeometry = new THREE.BoxGeometry(
                    blockSize,
                    blockSize,
                    blockSize
                );
                const cubeMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                
                // 黒い線（エッジ）を追加
                const edgeGeometry = new THREE.EdgesGeometry(cubeGeometry);
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                cube.add(edges);
                
                cube.position.set(
                    shape[i].x * blockSize,
                    shape[i].y * blockSize,
                    0
                );
                group.add(cube);
            }

            return { group, shape, color };
        }

        // 最初のテトリミノとネクストピースを生成
        let currentTetromino = createTetromino();
        nextTetromino = createTetromino();
        scene.add(currentTetromino.group);
        updateNextPieceDisplay();

        let posX = 4 * blockSize;  // 初期位置を中央に設定
        let posY = (numRows - 1) * blockSize;
        let dropSpeed = 500; // ミリ秒ごとの落下速度
        let lastDropTime = Date.now();
        
        // Next piece表示を更新
        function updateNextPieceDisplay() {
            if (nextRotationGroup) {
                nextScene.remove(nextRotationGroup);
            }
            
            nextPieceGroup = new THREE.Group();
            nextRotationGroup = new THREE.Group();
            
            // テトリミノの境界を計算
            let minX = Math.min(...nextTetromino.shape.map(block => block.x));
            let maxX = Math.max(...nextTetromino.shape.map(block => block.x));
            let minY = Math.min(...nextTetromino.shape.map(block => block.y));
            let maxY = Math.max(...nextTetromino.shape.map(block => block.y));
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            for (let i = 0; i < nextTetromino.shape.length; i++) {
                const cubeGeometry = new THREE.BoxGeometry(
                    blockSize,
                    blockSize,
                    blockSize
                );
                const cubeMaterial = new THREE.MeshBasicMaterial({
                    color: nextTetromino.color,
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                
                // 黒い線（エッジ）を追加
                const edgeGeometry = new THREE.EdgesGeometry(cubeGeometry);
                const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                cube.add(edges);
                
                // 中心を原点にして配置
                cube.position.set(
                    (nextTetromino.shape[i].x - centerX) * blockSize,
                    (nextTetromino.shape[i].y - centerY) * blockSize,
                    0
                );
                nextPieceGroup.add(cube);
            }
            
            nextRotationGroup.add(nextPieceGroup);
            nextRotationGroup.position.set(1.5, 1, 0);  // 表示エリアの中央に配置
            nextScene.add(nextRotationGroup);
        }
        
        // スコア表示を更新
        function updateDisplay() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }

        let clearEffectGroup = null;
        
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            
            // ライン消去アニメーション中は落下を一時停止
            if (clearAnimationStart) {
                const elapsed = currentTime - clearAnimationStart;
                const progress = Math.min(elapsed / clearAnimationDuration, 1);
                
                // 前のエフェクトを削除
                if (clearEffectGroup) {
                    scene.remove(clearEffectGroup);
                }
                
                // 新しいエフェクトを描画
                clearEffectGroup = drawClearingEffect(progress);
                scene.add(clearEffectGroup);
                
                // アニメーション終了
                if (progress >= 1) {
                    scene.remove(clearEffectGroup);
                    clearEffectGroup = null;
                    finishLineClear();
                }
            } else {
                // 通常の落下処理
                if (currentTime - lastDropTime > dropSpeed) {
                    posY -= blockSize; // 下に移動

                    if (checkCollision()) {
                        posY += blockSize; // 衝突した場合は元の位置に戻す
                        addToBoard();
                        resetTetromino();
                    }

                    lastDropTime = currentTime;
                }

                // Tetrominoの位置を更新
                currentTetromino.group.position.set(posX, posY, 0);
            }

            // メインシーンをレンダリング
            renderer.render(scene, camera);
            
            // ネクストピースをレンダリング
            if (nextRotationGroup) {
                nextRotationGroup.rotation.y += 0.01; // 回転アニメーション
                nextRenderer.render(nextScene, nextCamera);
            }
        }

        function checkCollision() {
            const x = Math.floor(posX / blockSize);
            const y = Math.floor(posY / blockSize);

            // テトリミノの各ブロック位置を確認
            for (const block of currentTetromino.shape) {
                const checkX = x + block.x;
                const checkY = numRows - 1 - (y + block.y);

                // 底に達した場合
                if (checkY >= numRows) {
                    return true;
                }

                // 左右の壁を超えた場合
                if (checkX < 0 || checkX >= numCols) {
                    return true;
                }

                // 既存のブロックに衝突した場合
                if (checkY >= 0 && checkY < numRows && board[checkY][checkX] !== 0) {
                    return true;
                }
            }

            return false;
        }

        function addToBoard() {
            const x = Math.floor(posX / blockSize);
            const y = Math.floor(posY / blockSize);
            const colorIndex = tetrominoColors.indexOf(currentTetromino.color) + 1;

            for (const block of currentTetromino.shape) {
                const boardX = x + block.x;
                const boardY = numRows - 1 - (y + block.y);

                if (boardY >= 0 && boardY < numRows && boardX >= 0 && boardX < numCols) {
                    board[boardY][boardX] = colorIndex;
                }
            }

            // ライン消去をチェック
            clearLines();
            
            scene.remove(boardGroup);
            boardGroup = drawBoard();
            scene.add(boardGroup);
        }

        function resetTetromino() {
            scene.remove(currentTetromino.group); // 前のテトリミノを削除
            
            // ネクストピースを現在のピースにする
            currentTetromino = nextTetromino;
            nextTetromino = createTetromino();
            updateNextPieceDisplay();
            
            posX = 4 * blockSize;
            posY = (numRows - 1) * blockSize;
            scene.add(currentTetromino.group);
            
            // ゲームオーバーチェック
            if (checkCollision()) {
                alert(`Game Over!\nScore: ${score}\nLines: ${lines}\nLevel: ${level}`);
                // ボードをリセット
                board = createBoard(numRows, numCols);
                scene.remove(boardGroup);
                boardGroup = drawBoard();
                scene.add(boardGroup);
                
                // スコアをリセット
                score = 0;
                lines = 0;
                level = 1;
                dropSpeed = 500;
                updateDisplay();
            }
        }

        // キーボード操作の追加
        document.addEventListener('keydown', (event) => {
            // ライン消去アニメーション中は操作を無効化
            if (clearAnimationStart) return;
            
            if (event.key === 'ArrowLeft') {
                // 左移動
                posX -= blockSize;
                if (checkCollision()) {
                    posX += blockSize; // 衝突したら戻す
                }
            } else if (event.key === 'ArrowRight') {
                // 右移動
                posX += blockSize;
                if (checkCollision()) {
                    posX -= blockSize; // 衝突したら戻す
                }
            } else if (event.key === 'ArrowDown') {
                // 高速落下
                posY -= blockSize;
                if (checkCollision()) {
                    posY += blockSize;
                    addToBoard();
                    resetTetromino();
                }
            } else if (event.key === ' ') {
                // 瞬間落下（ハードドロップ）
                while (!checkCollision()) {
                    posY -= blockSize;
                }
                posY += blockSize; // 衝突位置から1つ戻す
                addToBoard();
                resetTetromino();
            } else if (event.key === 'ArrowUp' || event.key === 'z' || event.key === 'Z') {
                // 回転
                rotateTetromino();
            }
            
            // Tetrominoの位置を即座に更新
            currentTetromino.group.position.set(posX, posY, 0);
        });

        // テトリミノの回転機能
        function rotateTetromino() {
            // 元の形状を保存
            const originalShape = JSON.parse(JSON.stringify(currentTetromino.shape));
            
            // 回転の中心を計算
            let minX = Math.min(...currentTetromino.shape.map(block => block.x));
            let maxX = Math.max(...currentTetromino.shape.map(block => block.x));
            let minY = Math.min(...currentTetromino.shape.map(block => block.y));
            let maxY = Math.max(...currentTetromino.shape.map(block => block.y));
            let centerX = (minX + maxX) / 2;
            let centerY = (minY + maxY) / 2;
            
            // 形状を回転（時計回り）
            for (let i = 0; i < currentTetromino.shape.length; i++) {
                let relX = currentTetromino.shape[i].x - centerX;
                let relY = currentTetromino.shape[i].y - centerY;
                currentTetromino.shape[i].x = Math.round(-relY + centerX);
                currentTetromino.shape[i].y = Math.round(relX + centerY);
            }
            
            // 衝突チェック
            if (checkCollision()) {
                // 衝突したら元に戻す
                currentTetromino.shape = originalShape;
            } else {
                // 回転が成功したら3Dオブジェクトを更新
                scene.remove(currentTetromino.group);
                const color = currentTetromino.color;
                const group = new THREE.Group();
                
                for (let i = 0; i < currentTetromino.shape.length; i++) {
                    const cubeGeometry = new THREE.BoxGeometry(
                        blockSize,
                        blockSize,
                        blockSize
                    );
                    const cubeMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                    });
                    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    
                    // 黒い線（エッジ）を追加
                    const edgeGeometry = new THREE.EdgesGeometry(cubeGeometry);
                    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
                    const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                    cube.add(edges);
                    
                    cube.position.set(
                        currentTetromino.shape[i].x * blockSize,
                        currentTetromino.shape[i].y * blockSize,
                        0
                    );
                    group.add(cube);
                }
                
                currentTetromino.group = group;
                scene.add(currentTetromino.group);
                currentTetromino.group.position.set(posX, posY, 0);
            }
        }

        // パーティクルのランダム速度を保存
        const particleVelocities = new Map();
        
        // ライン消去エフェクトを描画
        function drawClearingEffect(progress) {
            const effectGroup = new THREE.Group();
            
            for (const rowIndex of clearingLines) {
                for (let col = 0; col < numCols; col++) {
                    if (board[rowIndex][col]) {
                        const blockKey = `${rowIndex}-${col}`;
                        
                        // 花火のようなパーティクル
                        const particleCount = 15; // より多くのパーティクル
                        
                        // 初回のみ速度を生成
                        if (!particleVelocities.has(blockKey)) {
                            const velocities = [];
                            for (let p = 0; p < particleCount; p++) {
                                velocities.push({
                                    x: (Math.random() - 0.5) * 10,
                                    y: (Math.random() - 0.3) * 12, // 上方向に偏る
                                    z: (Math.random() - 0.5) * 8
                                });
                            }
                            particleVelocities.set(blockKey, velocities);
                        }
                        
                        const velocities = particleVelocities.get(blockKey);
                        
                        for (let p = 0; p < particleCount; p++) {
                            // パーティクルサイズをランダムに
                            const size = Math.random() * 0.2 + 0.1;
                            const particleGeometry = new THREE.SphereGeometry(
                                blockSize * size * (1 - progress * 0.5)
                            );
                            
                            // 花火のような色（黄色、オレンジ、赤、白）
                            const colors = [
                                0xFFFF00, // 黄色
                                0xFFA500, // オレンジ
                                0xFF4500, // 赤オレンジ
                                0xFF0000, // 赤
                                0xFFFFFF, // 白
                                0x00FFFF, // シアン
                                0xFF00FF  // マゼンタ
                            ];
                            const color = colors[Math.floor(Math.random() * colors.length)];
                            
                            const particleMaterial = new THREE.MeshBasicMaterial({
                                color: color,
                                transparent: true,
                                opacity: (1 - progress) * (0.8 + Math.random() * 0.2),
                                emissive: color,
                                emissiveIntensity: 1
                            });
                            
                            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                            
                            // 重力を考慮した物理的な動き
                            const vel = velocities[p];
                            const gravity = -9.8;
                            const time = progress * 0.5;
                            
                            particle.position.set(
                                col * blockSize + vel.x * time,
                                (numRows - 1 - rowIndex) * blockSize + vel.y * time + 0.5 * gravity * time * time,
                                vel.z * time
                            );
                            
                            // 光る尾を作る
                            if (progress < 0.7) {
                                const trailGeometry = new THREE.CylinderGeometry(
                                    blockSize * 0.02,
                                    blockSize * 0.05,
                                    blockSize * 0.3 * (1 - progress)
                                );
                                const trailMaterial = new THREE.MeshBasicMaterial({
                                    color: color,
                                    transparent: true,
                                    opacity: (1 - progress) * 0.5,
                                    emissive: color,
                                    emissiveIntensity: 0.5
                                });
                                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                                trail.position.copy(particle.position);
                                trail.lookAt(
                                    col * blockSize,
                                    (numRows - 1 - rowIndex) * blockSize,
                                    0
                                );
                                effectGroup.add(trail);
                            }
                            
                            // パーティクルを回転
                            particle.rotation.x = Math.random() * Math.PI * 8 * progress;
                            particle.rotation.y = Math.random() * Math.PI * 8 * progress;
                            particle.rotation.z = Math.random() * Math.PI * 8 * progress;
                            
                            effectGroup.add(particle);
                        }
                        
                        // 爆発の中心に明るい閃光
                        if (progress < 0.3) {
                            const flashGeometry = new THREE.SphereGeometry(
                                blockSize * (1 - progress * 3)
                            );
                            const flashMaterial = new THREE.MeshBasicMaterial({
                                color: 0xFFFFFF,
                                transparent: true,
                                opacity: (1 - progress * 3) * 0.8,
                                emissive: 0xFFFFFF,
                                emissiveIntensity: 2
                            });
                            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
                            flash.position.set(
                                col * blockSize,
                                (numRows - 1 - rowIndex) * blockSize,
                                0
                            );
                            effectGroup.add(flash);
                        }
                        
                        // 元のブロックをフェードアウト（サイズは維持）
                        const cubeGeometry = new THREE.BoxGeometry(
                            blockSize,
                            blockSize,
                            blockSize
                        );
                        const cubeMaterial = new THREE.MeshBasicMaterial({
                            color: tetrominoColors[board[rowIndex][col] - 1],
                            transparent: true,
                            opacity: Math.max(0, 1 - progress * 2) // 早めにフェードアウト
                        });
                        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                        
                        if (progress < 0.5) { // エッジも早めに消す
                            const edgeGeometry = new THREE.EdgesGeometry(cubeGeometry);
                            const edgeMaterial = new THREE.LineBasicMaterial({ 
                                color: 0x000000, 
                                linewidth: 2,
                                transparent: true,
                                opacity: 1 - progress * 2
                            });
                            const edges = new THREE.LineSegments(edgeGeometry, edgeMaterial);
                            cube.add(edges);
                        }
                        
                        cube.position.set(
                            col * blockSize,
                            (numRows - 1 - rowIndex) * blockSize,
                            0
                        );
                        
                        effectGroup.add(cube);
                    }
                }
            }
            
            return effectGroup;
        }

        // ライン消去機能の追加
        function clearLines() {
            const linesToClear = [];
            
            for (let row = numRows - 1; row >= 0; row--) {
                let isFullLine = true;
                for (let col = 0; col < numCols; col++) {
                    if (board[row][col] === 0) {
                        isFullLine = false;
                        break;
                    }
                }
                
                if (isFullLine) {
                    linesToClear.push(row);
                }
            }
            
            if (linesToClear.length > 0) {
                // エフェクトアニメーションを開始
                clearingLines = linesToClear;
                clearAnimationStart = Date.now();
                
                // スコア計算（テトリス方式）
                const lineScores = [0, 100, 300, 500, 800];
                score += lineScores[Math.min(linesToClear.length, 4)] * level;
                lines += linesToClear.length;
                
                // レベルアップ（10ライン毎）
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropSpeed = Math.max(100, 500 - (level - 1) * 50); // レベルが上がるとスピードアップ
                }
                
                updateDisplay();
            }
        }
        
        // アニメーション終了時にラインを実際に削除
        function finishLineClear() {
            // ラインを削除（逆順でソートして下から削除）
            clearingLines.sort((a, b) => b - a);
            for (const row of clearingLines) {
                board.splice(row, 1);
                board.unshift(new Array(numCols).fill(0));
            }
            
            // ボードを再描画
            scene.remove(boardGroup);
            boardGroup = drawBoard();
            scene.add(boardGroup);
            
            // エフェクト状態をリセット
            clearingLines = [];
            clearAnimationStart = null;
            particleVelocities.clear(); // パーティクル速度もクリア
        }

        animate();
    </script>
</body>

</html>
